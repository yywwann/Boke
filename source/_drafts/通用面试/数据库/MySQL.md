#### mysql 有哪些隔离级别

   1、未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据

   2、提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)

   3、可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读，但是innoDB解决了幻读

   4、串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

而默认的事务处理级别就是【REPEATABLE-READ】，也就是可重复读。

#### 怎么实现隔离级别

   MVCC

#### 有哪些数据库引擎

      1. innodb，ISAM，MyISAM

- Innodb

  1. 支持事务, 实现四种标准隔离级别

  2. 支持外键

  3. 支持行级锁

  4. B+Tree的索引结构, 索引文件本身就是数据文件, 即B+Tree的数据域存储的就是实际数据, 这种索引就是**聚集索引**。这个索引的key就是数据表的主键, 因此InnoDB表数据文件本身就是主索引。

     InnBD的辅助索引数据域存储的也是相应记录主键的值而不是地址, 所以当以辅助索引查找时, 会先根据辅助索引找到主键, 再根据主键索引找到实际的数据。

     所以InnoDB不建议使用过长的主键, 否则会导致辅助索引变得过大。建议使用自增的字段作为主键, 这样B+Tree的每一个节点都会被顺序的填满, 而不会频繁的分裂调整, 有效的提升插入数据的效率。

  5. `select count(*) from table` 需要扫描全表

- Mylsam

  1. 不支持事务

  2. 不支持行级锁

  3. 不支持外键

  4. B+Tree的索引结构, 数据域存储的是键值的地址, 属于非聚集索引
  5. `select count(*) from table` 可直接读出行数

#### 为什么用自增列作为主键

   1. 数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放。因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）
   2. 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页
   3. 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置。此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销。同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

#### **为什么使用数据索引能提高效率**

   1. 数据索引的存储是有序的
   2. 在有序的情况下，通过索引查询一个数据是无需遍历索引记录的
   3. 极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)

#### **B+树索引和哈希索引的区别**

   1. B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的。![](https://chy-cdn.oss-cn-hangzhou.aliyuncs.com/各种面试题/1625643974.jpeg)
   2. 哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的，![](https://chy-cdn.oss-cn-hangzhou.aliyuncs.com/各种面试题/1625643968.jpeg)

#### **哈希索引的优势：**

   1. **等值查询，**哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）

#### **哈希索引不适用的场景：**

   1. 不支持范围查询
   2. 支持索引完成排序
   3. 不支持联合索引的最左前缀匹配规则

#### 最左前缀匹配规则

#### join 操作

    - `left join` 返回包括左表中的所有记录和右表中联结字段相等的记录
    - `right join`返回包括右表中的所有记录和左表中联结字段相等的记录
    - `inner join` 只返回两个表中联结字段相等的行


#### ACID 

- 原子性
- 一致性
- 隔离性
- 持久性

#### MySQL引擎

 