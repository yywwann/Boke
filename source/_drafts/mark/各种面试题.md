# 各种面试题

## web 网络
1. #### 输入网址之后到网页显示信息之间发生了什么？
2. #### 浏览器是怎么渲染页面的？


## c++
1. #### c++里有哪几种 map
2. #### selsect 和 epoll
3. #### 面对对象几大特征

## 进程线程
1. https://blog.csdn.net/u010851789/article/details/97613703
2. #### 什么是进程和线程
   
   1. 进程是资源分配和调度的一个独立单元；线程是 cpu 调度的基本单元
   2. 同一个进程中可以包括多个线程，并且线程共享整个进程的资源，一个进程至少包含换一个线程
   3. 进程的创建用 fork 或者 vfork；线程的创建调用 pthread_creat，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中其他线程的结束
   4. 线程是轻量级的进程，他的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的。
   5. 多线程执行时一般需要进行同步和互斥，因为他们共享同一进程的所有资源
   6. 
3. #### 为什么要有进程和线程
   
   1. 进程属于在 CPU 和系统资源等方面提供的抽象，能够有效提高 CPU 的利用率
   2. 线程是在进程这个层次上提供的一层并发的抽象
      1. 能够使系统在同一时间能够做多件事情
      2. 当进程遇到阻塞时，例如等待输入，线程能够使不依赖输入数据的工作继续执行
      3. 可以有效地利用多处理器和多核计算机
   3. 进程和线程的主要差别在于他们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。
4. #### 线程的通讯方式
   
   1. 通道
   2. 消息队列，基于消息的，用无亲缘关系的进程间通信，主要函数 msgget/msgsend/msgrecv/msgctl
   3. 信号量，相同于一个把互斥锁，通过 p\v 操作，主要函数 semget/semop/semctl
   4. 共享内存，是进程间通信速度最快的，所以用经常是集合信号量或互斥锁来实现同步
5. #### 什么是孤儿进程，什么是僵尸进程，什么是守护进程
   
   1. 孤儿进程：一个父进程退出。而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程；孤儿进程将被 init 进程（进程号 1）所收养，并由 init 进程对他们完成状态收集工作；孤儿进程会被 init 进程收养，所以危害不大
   2. 僵尸进程：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 来获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。如果僵尸进程过多，会消耗大量的进程 pid，导致系统不能产生新的进程，所以需要避免
   3. 守护进程：守护进程是一个在后台运行且不受任何终端控制的进程，用于执行特定的系统任务。
6. #### 多线程的缺点
   
   1. 等待使用共享资源时造成程序的运行速度变慢，比如打印机这种独占性的共享资源。
   2. 对线程管理要求额外的 CPU 开销，线程的使用会给系统带来上下文切换额外的负担
   3. 线程的死锁。对共享资源加锁实现同步的过程中可能会死锁。
   4. 对共有变量的同时读或写，可能会造成脏读等。、
7. #### 适合多线程处理的任务有哪些
   
   1. 耗时或大量占用处理器的任务阻塞用户界面操作
   2. 各个任务必须等待外部资源

##  TCP和 UDP

1. #### TCP 和 UDP 的区别

   1. tcp：基于连接，要求系统资源较多，数据流模式，保证数据正确性，保证数据顺序
   2. udp：基于无连接，要求系统资源较少，程序结构简单，数据报模式，可能丢包，不保证数据顺序

2. #### TCP 靠什么保证可靠性

3. #### TCP 和 UDP 的使用场景

   1. TCP：
   2. UDP：
      1. 面向数据报方式
      2. 网络数据大多为短消息
      3. 拥有大量 client
      4. 对数据安全性无特殊要求
      5. 网络负担非常重，但对响应速度要求高

4. #### TCP

   1. ![](https://img-blog.csdn.net/20180410135625408?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dyZWVudGVhbGM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

5. #### UDP

   1. ![](https://img-blog.csdn.net/20180410135845213?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dyZWVudGVhbGM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

   

6. #### TCP、UDP 哪个效率高

7. #### TCP 三次握手

   1. ![](https://img-blog.csdn.net/20180410140138631?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dyZWVudGVhbGM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
   2. TCP 服务器进程先创建传输控制块 TCB，时刻准备接受客户端进程的连接请求，此时服务器进入 LISTEN 监听状态；
   3. TCP 客户端进程首先创建传输控制块 TCB，然后向服务器发出连接请求报文，这是报文首部中的同步位 SYN=1，同时选择一个初始序列号 seq=x，此时 TCP 客户端进入 SYN-SENT（同步已发送状态）状态。TCP 规定，SYN 报文段（SYN=1 的报文段）不能携带数据，但需要消耗掉一个序号。
   4. TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该ACK=1，SYN=1，确认号是 ~~ack=~~x+1，同时也要给自己初始化一个序列号 seq=y，此时 TCP 服务器进程进入了 SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。
   5. TCP 客户端进程收到确认后，还要向服务器给出确认。确认报文的 ACK=1，ack=y+1，自己的序列号 seq=y+1，此时 TCP 连接建立，客户端进入 ESTABLISHED（已建立连接）状态。TCP 规定，ACK 报文段可以携带数据，但是如果不携带数据则不消耗序号。
   6. 当服务器收到客户端的确认后也进入ESTABLISHED（已建立连接）状态，此后双方就可以开始通信了。

8. #### 为什么 TCP 客户端最后还要发送一次确认呢？

   1. 防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。
2. 如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。                                如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。
   
9. #### TCP 四次挥手

   1. ![](https://img-blog.csdn.net/20180410140623642?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dyZWVudGVhbGM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
   2. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为 seq=u（等于前面已经传送过来的数据的最后一个字节的序号+1），此时，客户端进入 FIN-WAIT-1（等待终止 1）状态。TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。
   3. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。
   4. 客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
   5. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。
   6. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时客户端就进入了TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSE 状态。
   7. 服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。

10. #### 为什么客户端最后还要等待 2MSL？

    1. 第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。
    2. 第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

11. #### 为什么建立连接是三次握手，关闭连接确是四次挥手呢？

    1. 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 
       而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

12. #### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

    1. TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

13. #### 滑动窗口

14. #### 拥塞控制

## 数据库
1. #### mysql 有哪些隔离级别

2. #### 怎么实现隔离级别

3. #### 有哪些数据库引擎

   1. innodb，ISAM，MyISAM

4. #### 为什么用自增列作为主键

   1. 数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放。因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）
   2. 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页
   3. 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置。此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销。同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

5. #### **为什么使用数据索引能提高效率**

   1. 数据索引的存储是有序的
   2. 在有序的情况下，通过索引查询一个数据是无需遍历索引记录的
   3. 极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)

6. #### **B+树索引和哈希索引的区别**

   1. B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的。![](https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdYnMu5lfXNAYzW0PPSOB8Pss8E5IlpSXicQbuCj5p3fN1vGtKkdUgeZ4IvYBx4IlFMLI4peDFvTV2w/640?wx_fmt=jpeg)
   2. 哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的，![](https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdYnMu5lfXNAYzW0PPSOB8PsAdicCricepbjicRIBIOlKdDPWlHroEiaYVgdDgicMMWbsuIlmmA4kOEVVog/640?wx_fmt=jpeg)

7. #### **哈希索引的优势：**

   1. **等值查询，**哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）

8. #### **哈希索引不适用的场景：**

   1. 不支持范围查询
   2. 支持索引完成排序
   3. 不支持联合索引的最左前缀匹配规则

9. #### 最左前缀匹配规则

10. #### join 操作

11. 
